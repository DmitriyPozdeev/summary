<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Неизвестный </title></head><body>
<p>Потоки</p>
<p>В каждом языке есть собственный способ напечатать результат на экран. С точки зрения операционной системы, которая запускает программу, все они работают абсолютно идентично.</p>
<p>При старте любой программы операционная система связывает с ней три так называемых потока: STDIN (Standar<em>d</em> Input), STDOUT (Standar<em>d</em> Output) и STDERR. Для языка программирования, они выглядят как файлы и взаимодействие с ними происходит как с файлами. STDOUT как раз отвечает за вывод на экран. Каждый раз, когда в программе (на любом языке) происходит печать на экран, функция печати, на самом деле, записывает с помощью функции write данные в STDOUT, а вот уже операционная система решает куда вывести результат. По умолчанию вывод происходит на экран терминала.</p>
<p>ЯП write STDOUT</p>
<p>Ответственность за взаимодействие с железом целиком и полностью лежит на плечах операционной системы, а программы могут только лишь попросить операционную систему выполнить ту или иную задачу.</p>
<p>ОС позволяет подменять эти потоки при старте системы, что открывает интересные возможности. Например, вывод любой команды, запущенной в баше, можно записать в файл вместо вывода на экран.</p>
<p>$ ls -la &gt; output</p>
<p>Запустив эту команду, вы увидите, что на экране ничего не отобразилось, но в текущей директории появился файл output.</p>
<p>Это называется перенаправление потоков. Символ &gt; означает, что нужно взять вывод из команды, указанной слева, и отправить его в файл, указанный справа. &gt; всегда перезаписывает файл. Такое перенаправление работает с абсолютно любой командой, которая выводит результаты своей работы на экран.</p>
<p>Если нужно не перезаписывать, а добавлять, то используйте &gt;&gt;.</p>
<p>STDERR по умолчанию идёт на экран. Он позволяет отделить нормальный вывод программы от возникающих ошибок. Такой подход удобен при ведении логов, для реагирования и отладки. Будьте осторожны, перенаправление вывода в файл перенаправляет только STDOUT. Убедиться в этом очень просто. Если попробовать перейти в несуществующую директорию, то команда cd выдаст ошибку:</p>
<p>$ cd lala</p>
<p>-bash: cd: lala: No such file or directory</p>
<p>Теперь попробуем перенаправить вывод в файл output</p>
<p>$ cd lala &gt; output</p>
<p>-bash: cd: lala: No such file or directory</p>
<p>Перенаправление есть, но сообщение вывелось на экран. Это произошло именно по той причине, что STDERR остался привязан к экрану, а внутри файла output — пустота. Решить эту задачу можно двумя способами. Перенаправив STDERR в STDOUT, либо отправив их оба в файл.</p>
<p>Перенаправление STDERR в STDOUT</p>
<p>$ cd lala &gt; output 2&gt;&amp;1</p>
<p>$ cat output</p>
<p>-bash: cd: lala: No such file or directory</p>
<p>2 - в данном случае обозначает номер потока. В POSIX, за каждым потоком закреплен определенный номер, который является файловым дескриптором если быть точным: STDIN — 0, STDOUT — 1, STDERR — 2. Конструкцию 2&gt;&amp;1 нужно просто запомнить, она говорит о том, что поток с номером 2 отправляем в поток с номером 1</p>
<p>Перенаправление STDERR бывает полезно само по себе, без вывода в файл.</p>
<p>$ cd lala 2&gt;&amp;1</p>
<p>-bash: cd: lala: No such file or directory</p>
<p>Перенаправление обоих потоков в файл</p>
<p>$ cd lala &amp;&gt; output</p>
<p>$ cat output</p>
<p>-bash: cd: lala: No such file or directory</p>
<p>Пайплайн(Конвейер) Pipeline</p>
<p>Благодаря пайплайну можно соединять программы и протаскивать данные сквозь них, как сквозь цепочку функций, каждая из которых выступает в роли преобразователя или фильтра.</p>
<p>Часто возникает задача грепать по нескольким словам. Не важно, как они расположены внутри строки, главное, что они встречаются там вместе. </p>
<p>$ grep alias .bashrc | grep color</p>
<p>| — этот символ называется пайп, он указывает шелу взять STDOUT одного процесса и соединяет его с STDIN другого процесса. Поскольку grep принимает на вход текст (как я говорил в прошлом уроке, все утилиты, которые читают файлы, могут принимать данные через STDIN) и возвращает текст, то его можно комбинировать бесконечно.</p>
<p>cat source | grep Dog | uniq | sort</p>
<p>1.Читается файл source</p>
<p>2.Входные данные грепаются по подстроке "Dog"</p>
<p>3.Убираются дубли (в исходном файле две одинаковых строки "Dog")</p>
<p>4.Входные данные сортируются и выводятся на экран</p>
<p>Пайплайн стал основой Unix философии, которая звучит так:</p>
<pre><code>Пишите программы, которые делают что-то одно и делают это хорошо.

Пишите программы, которые бы работали вместе.

Пишите программы, которые бы поддерживали текстовые потоки, поскольку это универсальный интерфейс.
</code></pre>
<p>Именно поэтому большинство утилит работают с сырым текстом — принимают его на вход и возвращают в STDOUT. Такой подход позволяет получать сложное поведение из крайне простых составных блоков. Такая концепция называется стандартные интерфейсы и хорошо отражена в конструкторах Lego.</p>
<p>Манипулирование файловой структурой</p>
<p>mkdir - создание директории -p, который создаёт директории рекурсивно.</p>
<p>touch - создание файла</p>
<p>rm - удаление файла -r режим рекурсивного (r - recursion) удаления содержимого директорий </p>
<p>mv - В nix системах не существует понятия "переименовать файл". Переименование всегда равносильно перемещению</p>
<p>cp - копирование файлов и директорий Для копирования директории нужно добавить флаг -r (recursive).</p>
<p>Переменные окружения</p>
<p>Они существуют в рамках запущенной сессии командного интерпретатора, подгружаются туда во время его инициализации (но это не единственный путь их появления). Посмотреть установленные переменные можно командой env (environment). </p>
<p>Основное предназначение переменных окружения — конфигурация системы и программ. Их удобство заключается в универсальности и отвязке от способа появления этих значений в системе. </p>
<p>Существует некоторый базовый набор переменных, которые всегда устанавливаются башем при старте. Они используются большим количеством утилит и нужны для нормального функционирования системы, одну из таких переменных мы уже знаем — это HOME.</p>
<p>По умолчанию, любой запущенный процесс получает все переменные родительского процесса (процесс-создатель). Именно поэтому команда cd может прочитать переменную HOME. Переменные можно создавать и изменять в любой момент времени, например:</p>
<h1 id="echo">Для вывода переменной используется echo, а перед самой переменной ставится знак $.</h1>
<p>$ echo $HOME</p>
<p>/home/kirill.m</p>
<h1 id="_1">Для установки знак $ не нужен.</h1>
<h1 id="_2">Очень важно чтобы не было пробелов вокруг знака равно</h1>
<p>$ HOME=/tmp</p>
<h1 id="_3">Достаточно выполнить присваивание слева от запускаемой команды</h1>
<p>$ HOME=/tmp cd</p>
<p>/tmp$ pwd</p>
<p>/tmp</p>
<p>$ cd</p>
<p>~$ pwd</p>
<p>/home/kirill.m</p>
<p>~$ echo $HOME</p>
<p>/home/kirill.m</p>
<p>В этот раз произошел переход в настоящую домашнюю директорию. Получается, что вызов выше изменил переменную только для того конкретного запуска. И действительно, существует два способа задавать значение переменной окружения: локальный и глобальный. </p>
<p>Когда мы указали HOME=/tmp прямо перед командой cd, то переменная не была изменена для текущей сессии — она была изменена для запущенной команды, в данном случае cd. Такой трюк можно проделывать с любой командой. Другой способ установки изменяет значение глобально, для всей сессии и выполняется так:</p>
<p>~$ export HOME=/tmp</p>
<p>/home/kirill.m$ cd</p>
<p>~$ pwd</p>
<p>/tmp</p>
<p>~$ echo $HOME</p>
<p>/tmp</p>
<p>Обратите внимание на то, что изменение происходит в рамках текущей сессии, другими словами, если у вас открыто две вкладки терминала, и в каждой загружен баш, то изменение произойдет только в той вкладке, в которой будет выполнена команда.</p>
<p>Особую роль среди переменных окружения играет переменная PATH. Она настолько важна для разработчиков и так часто возникают связанные с ней сложности, что этой переменной посвящён практически целый урок впереди.</p>
<p>Пользователи и Группы</p>
<p>Оболочка предоставляет утилиты, позволяющие анализировать права доступа к системе и изменять их.</p>
<p>Взаимодействие с ОС всегда ведётся от какого-то конкретного пользователя, созданного в системе. </p>
<p>Любой процесс, запускаемый в ОС, стартует от имени некоторого пользователя.  Возможности влияния на файловую систему ограничены правами пользователя, от имени которого запущен процесс. Не "пользователь запустил процесс", а "процесс запускается от имени пользователя". Работая в командной строке мы стартуем всё сами, но когда система загружается, то она стартует множество различных процессов и для многих из них создаются собственные пользователи с ограниченным набором прав. Команда ps (process status) выводит отчёт о работающих процессах. Информацию о том, какой процесс и под каким пользователем запущен, можно получить из вывода ps aux:</p>
<p>$ ps aux</p>
<h1 id="_4">Левый столбец имя пользователя</h1>
<p>root      7717  0.0  0.0   4244  1504 ?        S    10:52   0:00 mpstat 1 3</p>
<p>kirill.m  7718  0.0  0.1  36084  3236 pts/0    R+   10:52   0:00 ps aux</p>
<p>alexand+ 10542  0.0  0.1  21500  2892 pts/1    Ss+  10:10   0:00 -bash</p>
<p>root     11113  0.0  0.1  92796  2596 ?        Ss   08:50   0:00 sshd: kirill.m [priv]</p>
<p>Взаимодействие с файловой системой происходит через запуск тех или иных утилит, модифицирующих, создающих или анализирующих файловую структуру. Это значит, что запуская, например, touch, мы стартуем процесс от своего имени, внутри которого запускается программа touch. Она, в свою очередь, создаёт файл (если его не было) и делает вас владельцем нового файла. Кстати, модификация существующих файлов не влияет на владельца — для его смены нужно воспользоваться специальной утилитой. В домашней директории пользователя всё принадлежит пользователю (хотя, если постараться, то можно навертеть как угодно):</p>
<p>$ ls -la</p>
<p>total 44</p>
<p>drwxr-xr-x 5 kirill.m kirill.m 4096 Aug 29 11:34 .</p>
<p>drwxr-xr-x 8 root     root     4096 Apr 26 10:38 ..</p>
<p>-rw------- 1 kirill.m kirill.m 2540 Aug 30 07:26 .bash_history</p>
<p>-rw-r--r-- 1 kirill.m kirill.m  220 Aug 31  2015 .bash_logout</p>
<p>-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc</p>
<p>Третий столбец в этом выводе — как раз владелец. Единственная запись, которая выбивается из всего списка это .., то есть родительская директория. Её владельцем является root, о котором мы позже поговорим. Если хорошо подумать, то это логично — ведь директория /home не является собственностью пользователей системы:</p>
<p>$ ls -la /home/</p>
<p>total 32</p>
<p>drwxr-xr-x  8 root              root              4096 Apr 26 10:38 .</p>
<p>drwxr-xr-x 23 root              root              4096 Aug 27 06:53 ..</p>
<p>drwxr-xr-x  5 alexander.v       alexander.v       4096 Jan 22  2018 alexander.v</p>
<p>Каждый каталог в директории /home является домашним каталогом конкретного пользователя. Поэтому они все имеют разных владельцев, как правило, совпадающих с именем директории.</p>
<p>Имя пользователя в системе должно быть уникальным, но его можно менять. Если посмотреть под капот работы этой системы, то мы увидим, что имя пользователя связано с идентификатором, называемым UID. Это число, которое и определяет пользователя. Если поменяется имя пользователя, но идентификатор останется прежним, то все доступы останутся. Если же сменится идентификатор, то фактически сменится и пользователь. Соответственно, новый пользователь потеряет доступы ко всему старому. Посмотреть свой идентификатор можно разными способами. Первый способ — с помощью команды id:</p>
<p>$ id</p>
<p>uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)</p>
<p>Второй способ связан с просмотром одного важного файла, который является основным хранилищем пользователей в *nix системах. Да, это обычный текстовый файл, как и всё остальное.</p>
<p>$ cat /etc/passwd</p>
<p>root:x:0:0:root:/root:/bin/bash</p>
<p>daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</p>
<p>bin:x:2:2:bin:/bin:/usr/sbin/nologin</p>
<p>sys:x:3:3:sys:/dev:/usr/sbin/nologin</p>
<p>sync:x:4:65534:sync:/bin:/bin/sync</p>
<p>Кроме имени и идентификатора, здесь также указана домашняя директория пользователя (и её можно поменять), а так же шелл по умолчанию. Запись /usr/sbin/nologin говорит о том, что данный пользователь не может входить в систему. Такие пользователи нужны для запуска программ, имеющих ограниченные права, и им, естественно, не нужно входить в систему.</p>
<p>Кроме имени и идентификатора, здесь также указана домашняя директория пользователя (и её можно поменять), а так же шелл по умолчанию. Запись /usr/sbin/nologin говорит о том, что данный пользователь не может входить в систему. Такие пользователи нужны для запуска программ, имеющих ограниченные права, и им, естественно, не нужно входить в систему.</p>
<p>Кроме имени, у пользователей *nix систем есть связанное с ним понятие группа. Группа, как можно догадаться из названия, создана для группового доступа к разделяемому (общему) ресурсу (например, файлу). Например, у нас есть группа разработчиков, которые регулярно ходят на сервер, и им нужно дать одинаковые возможности по управлению определёнными файлами. Так как владелец у файла ровно один, то мы не можем решить этот вопрос через смену владельца, но можем через создание группы. Достаточно её создать и привязать к самому пользователю. Группы, ассоциированные с текущим пользователем, показываются в выводе команды id:</p>
<p>$ id</p>
<p>uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)</p>
<p>Здесь группа kirill.m является основной, такая группа может быть только одна, и именно в эту группу входят любые создаваемые файлы от имени текущего пользователя. Кроме основной, пользователь может входить в произвольное число дополнительных групп.</p>
<p>В любой *nix системе присутствует специальный пользователь root, или, как говорят, суперпользователь. Главная его особенность — это идентификатор со значением 0 (а имя в теории можно поменять). Этот пользователь имеет особое значение для системы и может выполнять абсолютно любые действия в системе.</p>
<p>Крайне не рекомендуется использовать этого пользователя на регулярной основе. И ни в коем случае нельзя входить под ним в систему. root — это прямой доступ ко всему и большая дыра в безопасности системы. Кроме того, систему очень легко убить, например, удалив случайно не тот файл или испортив важную конфигурацию, после чего вход в систему станет невозможным.</p>
<p>Несмотря на это, root нужен для выполнения некоторых привилегированных действий, которые недоступны обычным пользователям. </p>
<p>root sudo</p>
<p>Ситуаций, в которых необходимо повышать привилегии и выполнять команды от рута (пользователя root), довольно много. С некоторыми мы уже столкнулись, с другими познакомимся в следующих уроках:</p>
<pre><code>Установка новых программ

Навигация по чужим директориям

Изменение прав доступа и владельцев файлов, не принадлежащих текущему пользователю

Создание, редактирование и удаление файлов в местах, где не хватает прав текущего пользователя

Запуск программ, требующих повышенные привилегии
</code></pre>
<p>Стать другим пользователем, находясь прямо в системе, можно с помощью утилиты su (substitute user, switch user). Когда-то такой способ был основным, но сейчас он устарел и крайне не рекомендуется к использованию. Подробнее об этом можно прочитать в статье из дополнительных материалов. Основной способ повышать привилегии в современных системах — утилита sudo (substitute user and do — дословно "подменить пользователя и выполнить").</p>
<p>$ sudo -u nobody mkdir /tmp/test</p>
<h1 id="nobody">Файл создан от nobody</h1>
<p>Если стоит задача произвести сразу пачку действий от имени другого пользователя, то для этого можно запустить новую сессию поверх текущей:</p>
<p>$ sudo -i</p>
<p>$ id</p>
<p>uid=0(root) gid=0(root) groups=0(root)</p>
<p>Главное — не забыть переключиться обратно после завершения необходимых манипуляций. Для этого наберите exit.</p>
<p>Права доступа</p>
<p>Частая ошибка, с которой встречаются разработчики — ошибка доступа:</p>
<p>$ touch /etc/myfile</p>
<p>touch: cannot touch '/etc/myfile': Permission denied</p>
<p>Она говорит о том, что текущий пользователь не имеет прав на создание файлов в каталоге /etc.</p>
<p>Кроме имени пользователя и группы, с каждым файлом ассоциированы права доступа: r — чтение, w — запись и x — исполнение. Причём, эти права задаются для трёх типов пользователей: владельца (Owner), пользователей, входящих в ту же группу (Group) и остальных (Other) — тех, кто не попал в предыдущие две. Разберём на примере:</p>
<h1 id="ls-la">Пример строчки из вывода команды ls -la</h1>
<p>-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc</p>
<p>Запись слева представляет из себя один из вариантов описания прав доступа (permissions). Для удобства чтения разделим эту запись на группы символов - rw- r-- r--. Символ - в этой записи говорит о том, что перед нами обычный файл. За ним следует три группы, в каждой из которых по три символа. Каждая группа описывает доступы для разных типов пользователей. </p>
</body></html>