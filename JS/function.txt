Guard Expression

Подход, который я опишу, также называемый «паттерном», помогает лучше структурировать функцию и иногда сократить цикломатическую сложность. Рассмотрим пример:

const f = (age, sex) => {
  if (age >= 18) {
    if (sex === 'male') {
      return 'yes';
    } else if (sex === 'female') {
      return 'no';
    }
  }

  return null;
}
Она принимает на вход возраст и пол. Для людей, старше 18, в зависимости от пола возвращает строчку "yes" или "no". Для всех остальных — "null". В целом, с этой функцией все нормально, но кое-что можно улучшить.
Условие "вернуть null, если младше 18 лет" гораздо более простое и очевидное. Оно не подразумевает дальнейшего разветвления и сформулировано просто. Этим можно воспользоваться и произвести рефакторинг (улучшение работающего кода без изменения функциональности) таким образом, чтобы это условие отрабатывало первым.

const f = (age, sex) => {
  if (age < 18) {
    return null;
  }

  if (sex === 'male') {
    return 'yes';
  } else if (sex === 'female') {
    return 'no';
  }
}
Обратите внимание на то, что уровень вложенности понизился. Основная логика находится вне условных конструкций. В такой реализации функции сложнее ошибиться: все, что пишется ниже guard expression (первая проверка в данном случае), попадает под требование "от 18 и старше", а в первом примере код для этого условия нужно не забывать вставить внутрь соответствующего условия.

Нам уже знаком такой подход. Терминальные условия в рекурсиях выглядят точно также.

В будущих практиках и в реальной жизни он встречается повсеместно. Используйте его осознанно и понижайте энтропию.

Параметры по умолчанию
Параметры, которым "не досталось" аргумента, автоматически инициализируются значением undefined.
Бывают ситуации, когда заранее неизвестно будет ли вообще передан в ходе выполнения кода функции аргумент или будет ли переданный аргумент содержать осмысленное значение (отличное от значения undefined). В таких случаях удобно предусмотреть какое-нибудь дефолтное значение для параметра.
Тогда мы можем реализовать её следующим образом:

const greeting = name => console.log(`Hi, ${name ? name : 'anonymous'}!`);

JavaScript поддерживает механизм значений по умолчанию, позволяющий немного упростить код:

const greeting = (name = 'anonymous') => console.log(`Hi, ${name}!`);

greeting();
// => Hi, anonymous!

Кроме того, в значениях по умолчанию можно использовать идентификаторы:

const f = (x = Math.PI) => {};
И даже вызовы функций:

const f = (x, y = Math.sqrt(x)) => {};
Но не стоит злоупотреблять этим способом. Значения по умолчанию не всегда подходят для полноценного программирования. 


Выражение — код, выполнение которого возвращает значение. Инструкция — код, представляющий собой команду.

    Выражения — вычисляются.
    Инструкции — исполняются.

К выражениям относятся:

    Вызов функции
    Арифметические и логические операции
    Тернарный оператор
    и другие

К инструкциям относятся:

    for
    while
    break
    return
    if
    и другие

const x = () => console.log('hey')

    Создание функции: () => console.log('hey')
    Создание константы со значением в виде функции: const x =
допустимо написать и выполнить подобную программу: (a, b) => a + b


определение функции — это выражение, а значит оно возвращает значение, а именно — функцию. А раз определение функции — выражение, возвращающее функцию, то мы можем попробовать вызвать её без создания промежуточной константы:

// Определяем функцию v => v и тут же вызываем ее
(v => v)('run'); // => run

// Тот же код с использованием промежуточной константы.
// Попробуйте мысленно заменить `identity` на `v => v`, тогда
// получится (v => v)('run'). С выражениями так можно поступать всегда.
// const identity = v => v;
// identity('run'); // => run

Скобки вокруг определения функции — не какой-то особый синтаксис. Здесь они используются с той же целью, что и в арифметических операциях — для группировки. Без них выражение v => v('run') приобретает совсем другой смысл. В этом случае в нём создаётся функция, принимающая на вход другую функцию v и вызывающая её внутри с аргументом 'run'.

Попробуем усложнить:

identity(v => v)('run'); // => run
// (v => v)(v => v)('run') // => run


Функции — это такие же данные, как числа или строки, поэтому функции можно передавать в другие функции в виде аргументов, а также возвращать из функций. Мы даже можем определить функцию внутри другой функции и вернуть её наружу. И в этом нет ничего удивительного. Константы можно создавать где угодно.

const generateSumFinder = () => {
  const sum = (a, b) => a + b;     // создали функцию
  return sum;                      // и вернули её
};

const sum = generateSumFinder();   // sum теперь — функция, которую вернула функция generateSumFinder
sum(1, 5); // => 6                 // sum складывает числа

Можно даже обойтись без промежуточного создания константы:
generateSumFinder()(1, 5);    // => 6
// ((a, b) => a + b)(1, 5)
Всегда, когда видите подобные вызовы f()()(), знайте: функции возвращаются!

Теперь посмотрим, как еще можно описать функцию generateSumFinder:
const generateSumFinder = () => (a, b) => a + b;
Для понятности можно расставить скобки:

const generateSumFinder = () => ((a, b) => a + b);

Определение функции обладает правой ассоциативностью. Все, что находится справа от =>, считается телом функции. Количество вложений никак не ограничено. Вполне можно встретить и такие варианты:

const sum = x => y => z => x + y + z;

// расставим скобки для того чтобы увидеть как функции вложены друг в друга
// const sum = x => (y => (z => x + y + z));

Ту же функцию можно представить другим способом, вынеся каждую функцию в свою собственную константу. Этот способ полезен как мысленный эксперимент, чтобы понять где заканчивается одна и начинается другая функция, но сам по себе он не заработает, потому что теряется замыкание.

const inner1 = z => x + y + z;
const inner2 = y => inner1;
const sum = x => inner2;

Попробуем последовательно пройтись по вызовам функции выше, чтобы понять, как получается результат. После каждого вызова (кроме последнего) возвращается новая функция, в которую подставлено значение из внешней функции за счет замыкания.

sum(1)(3)(5); // => 9

const sum1 = x => y => z => x + y + z;

// sum(1);
const sum2 = y => z => 1 + y + z; // inner2

// sum(1)(3)
const sum3 = z => 1 + 3 + z; // inner1

// sum(1)(3)(5)
const sum4 = 1 + 3 + 5; // => 9
Как видно выше, sum1, sum2 и sum3 — это функции, а sum4 уже число, так как были вызваны все внутренние функции.

Давайте распишем все функции:

const sum = x => y => z => x + y + z;
// const sum = x => (y => (z => x + y + z));

  Функция sum принимает x и возвращает функцию, которая
  принимает y и возвращает функцию, которая
  принимает z и возвращает функцию, которая
  возвращает сумму x + y + z
  Попробуем развить идею функции callTwice из предыдущего урока. Напишем функцию generate, которая   не применяет функцию сразу, а генерирует новую.

const generate = f => arg => f(f(arg));
// const generate = f => (arg => f(f(arg)));
Функция generate принимает функцию в качестве аргумента и возвращает новую функцию. Внутри новой функции переданная изначально функция вызывается два раза.

generate(какая то функция) //Возвращает функцию (arg) => f(f(arg))
получается когда я переменной присваиваю generate(какая то функция), то переменная становится ф-цией 
const f1 = generate(какая то функция)  когда в f1 вернулась функция
у f1 значение (arg) => f(f(arg))
arg - это замыкание. Замыкание — это функция, «запомнившая» часть окружения, где она была задана. Функция замыкает в себе идентификаторы (все, что мы определяем) из лексической области видимости.

получается f1(6) это тоже что и (6) => f(f(6)) где f какая то функция, которая была аргументом при вызове generate

const f1 = generate(x => x ** 2);
const f2 = generate(x => x ** 2);
console.log(f1 === f2); // => false
Поэтому про любую функцию, которая возвращает функцию можно сказать что она генерирует функцию. Запомнить довольно просто, если вы где-то слышите или читаете что происходит генерация функций, значит кто-то их возвращает.

const generateDouble = f => arg => f(f(arg));
const f1 = generateDouble(Math.sqrt);
Когда generateDouble закончила работу и вернула новую функцию, экземпляр функции generateDouble исчез, уничтожился вместе с используемыми внутри аргументами.

Но та функция, которую вернула generateDouble все еще использует аргумент. В обычных условиях он бы навсегда исчез, но тут он «запомнился» или «замкнулся» внутри возвращенной функции. Технически внутренняя функция, как и любая другая в JS, связана со своим лексическим окружением, которое не пропадает, даже если функция покидает это окружение.
