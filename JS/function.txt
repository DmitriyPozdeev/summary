Guard Expression

Подход, который я опишу, также называемый «паттерном», помогает лучше структурировать функцию и иногда сократить цикломатическую сложность. Рассмотрим пример:

const f = (age, sex) => {
  if (age >= 18) {
    if (sex === 'male') {
      return 'yes';
    } else if (sex === 'female') {
      return 'no';
    }
  }

  return null;
}
Она принимает на вход возраст и пол. Для людей, старше 18, в зависимости от пола возвращает строчку "yes" или "no". Для всех остальных — "null". В целом, с этой функцией все нормально, но кое-что можно улучшить.
Условие "вернуть null, если младше 18 лет" гораздо более простое и очевидное. Оно не подразумевает дальнейшего разветвления и сформулировано просто. Этим можно воспользоваться и произвести рефакторинг (улучшение работающего кода без изменения функциональности) таким образом, чтобы это условие отрабатывало первым.

const f = (age, sex) => {
  if (age < 18) {
    return null;
  }

  if (sex === 'male') {
    return 'yes';
  } else if (sex === 'female') {
    return 'no';
  }
}
Обратите внимание на то, что уровень вложенности понизился. Основная логика находится вне условных конструкций. В такой реализации функции сложнее ошибиться: все, что пишется ниже guard expression (первая проверка в данном случае), попадает под требование "от 18 и старше", а в первом примере код для этого условия нужно не забывать вставить внутрь соответствующего условия.

Нам уже знаком такой подход. Терминальные условия в рекурсиях выглядят точно также.

В будущих практиках и в реальной жизни он встречается повсеместно. Используйте его осознанно и понижайте энтропию.

Параметры по умолчанию
Параметры, которым "не досталось" аргумента, автоматически инициализируются значением undefined.
Бывают ситуации, когда заранее неизвестно будет ли вообще передан в ходе выполнения кода функции аргумент или будет ли переданный аргумент содержать осмысленное значение (отличное от значения undefined). В таких случаях удобно предусмотреть какое-нибудь дефолтное значение для параметра.
Тогда мы можем реализовать её следующим образом:

const greeting = name => console.log(`Hi, ${name ? name : 'anonymous'}!`);

JavaScript поддерживает механизм значений по умолчанию, позволяющий немного упростить код:

const greeting = (name = 'anonymous') => console.log(`Hi, ${name}!`);

greeting();
// => Hi, anonymous!

Кроме того, в значениях по умолчанию можно использовать идентификаторы:

const f = (x = Math.PI) => {};
И даже вызовы функций:

const f = (x, y = Math.sqrt(x)) => {};
Но не стоит злоупотреблять этим способом. Значения по умолчанию не всегда подходят для полноценного программирования. 


Выражение — код, выполнение которого возвращает значение. Инструкция — код, представляющий собой команду.

    Выражения — вычисляются.
    Инструкции — исполняются.

К выражениям относятся:

    Вызов функции
    Арифметические и логические операции
    Тернарный оператор
    и другие

К инструкциям относятся:

    for
    while
    break
    return
    if
    и другие

const x = () => console.log('hey')

    Создание функции: () => console.log('hey')
    Создание константы со значением в виде функции: const x =
допустимо написать и выполнить подобную программу: (a, b) => a + b


определение функции — это выражение, а значит оно возвращает значение, а именно — функцию. А раз определение функции — выражение, возвращающее функцию, то мы можем попробовать вызвать её без создания промежуточной константы:

// Определяем функцию v => v и тут же вызываем ее
(v => v)('run'); // => run

// Тот же код с использованием промежуточной константы.
// Попробуйте мысленно заменить `identity` на `v => v`, тогда
// получится (v => v)('run'). С выражениями так можно поступать всегда.
// const identity = v => v;
// identity('run'); // => run

Скобки вокруг определения функции — не какой-то особый синтаксис. Здесь они используются с той же целью, что и в арифметических операциях — для группировки. Без них выражение v => v('run') приобретает совсем другой смысл. В этом случае в нём создаётся функция, принимающая на вход другую функцию v и вызывающая её внутри с аргументом 'run'.

Попробуем усложнить:

identity(v => v)('run'); // => run
// (v => v)(v => v)('run') // => run

