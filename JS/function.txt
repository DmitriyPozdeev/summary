Guard Expression

Подход, который я опишу, также называемый «паттерном», помогает лучше структурировать функцию и иногда сократить цикломатическую сложность. Рассмотрим пример:

const f = (age, sex) => {
  if (age >= 18) {
    if (sex === 'male') {
      return 'yes';
    } else if (sex === 'female') {
      return 'no';
    }
  }

  return null;
}
Она принимает на вход возраст и пол. Для людей, старше 18, в зависимости от пола возвращает строчку "yes" или "no". Для всех остальных — "null". В целом, с этой функцией все нормально, но кое-что можно улучшить.
Условие "вернуть null, если младше 18 лет" гораздо более простое и очевидное. Оно не подразумевает дальнейшего разветвления и сформулировано просто. Этим можно воспользоваться и произвести рефакторинг (улучшение работающего кода без изменения функциональности) таким образом, чтобы это условие отрабатывало первым.

const f = (age, sex) => {
  if (age < 18) {
    return null;
  }

  if (sex === 'male') {
    return 'yes';
  } else if (sex === 'female') {
    return 'no';
  }
}
Обратите внимание на то, что уровень вложенности понизился. Основная логика находится вне условных конструкций. В такой реализации функции сложнее ошибиться: все, что пишется ниже guard expression (первая проверка в данном случае), попадает под требование "от 18 и старше", а в первом примере код для этого условия нужно не забывать вставить внутрь соответствующего условия.

Нам уже знаком такой подход. Терминальные условия в рекурсиях выглядят точно также.

В будущих практиках и в реальной жизни он встречается повсеместно. Используйте его осознанно и понижайте энтропию.