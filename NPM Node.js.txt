 общий код
использовать git => набор общих файлов, который называется "библиотека".
общий код более низкого уровня Напр. финансовые библиотеки могут использовать функции для преобразования валют.  
Одни библиотеки зависят от других, те в свою очередь от третьих и так далее.
1.Появляются новые версии библиотек
2.Необходимо стандартизировать способ создания библиотек. 
3. Необходимость в автоматизированном средстве управления зависимостями: их обновлению, установке и удалению.
Всеми этими вопросами и занимаются пакетные менеджеры. В большинстве языков пакетный менеджер поставляется с самим языком, так как в современном мире сложно представить себе код, который не использует ни одной зависимости.

REPL Работает как командная оболочка, выполняя введённый код и выводя результат на экран
NPM это программа поставляемая вместе с Nodejs. В двух словах — Node.js это интерпретатор языка JavaScript. Сам по себе Node.js является C++ приложением, которое получает на входе JavaScript-код и выполняет его.
Библиотека - Сборник общих файлов (подпрограмм), используемых для разработки программного обеспечения
Пакет (Package) — базовая единица, которой управляет NPM как единым целым. Может содержать любое количество файлов и кода. NPM позволяет устанавливать пакеты, обновлять или удалять. NPM работает таким образом, что объединяет понятия "проект" и "библиотека" в одно целое. И то и другое оформляется, как пакет NPM. npm init - создание пакета 
Реестр (Registry) — хранилище пакетов NPM. 

Публикация пакета сводится к запуску команды npm publish в корне нашего проекта:
- Имя пакета уникально. 
- Вы зарегистрированы на сайте https://www.npmjs.com/ и выполнили локально аутентификацию, запустив в командной строке npm login 
- В случае обновления, версия нового пакета должна быть выше версии текущего опубликованного пакета. Версии в библиотеках в первую очередь нужны из-за обратной совместимости. Универсальный стандарт называется SEMVER. 1.23.5 :
-Первое число (1 в примере выше) — мажорная версия. Меняется только в случае серьезных изменений, как правило, ломающих обратную совместимость
-Второе число (23 в примере выше) — минорная версия. Не должна ломать обратную совместимость (в идеале). Меняется при добавлении новых возможностей.
-Третье число (5) — патч. Гарантировано не должна менять обратную совместимость (к сожалению такое бывает). Меняется только при исправлении багов.

отладить процесс публикации без добавления пакета в каталог NPM, когда мы не хотим добавлять пакет в общее хранилище, например, при разработке учебных приложений.
npm publish --dry-run

Зависимости
// По общепринятому соглашению, lodash импортируется под именем _
//Node.js напрямую не поддерживает синтаксис импортов и для их использования нужно подключить пакет Babel. 
import _ from 'lodash'; //внешняя зависисость   

// capitalize делает первую букву заглавной
_.capitalize('hello'); // Hello     _ это объект а .capitalize это метод объекта

При импорте кода из другой библиотеки, а не локального файла в наш проект(или библиотеку), мы получаем зависимость. 
Библиотека это общие подпрограмы записанные в файлы

Мое понимание. Есть файл проекта(пакета) index.js и в него импортированны другие файлы проекта, находящиеся так же в корне проекта. Импортируются файлы например вот так:
import example from './example'  //это грубо говоря внутренняя зависимость
Но если нет такого указания ./, то это внешняя зависимость

Перед 'lodash' нет указания текущей директории ./, именно так NPM понимает, что это внешняя зависимость, а не файл, лежащий рядом.
Все что импортируется, должно быть установлено локально в директорию node_modules лежащую в корне проекта. Делается это уже знакомой нам командой npm install, но в этот раз без флага глобальной установки
# Имя пакета всегда совпадает с именем, которое указывается в части импорта, идущей после from
# from 'lodash';
$ npm install lodash

При таком подходе зависимости ставятся в директорию node_modules, находящуюся в корне проекта. Кроме того, NPM создаст файл package-lock.json. 
Теперь NPM знает о том что ваш проект (он же пакет) зависит от lodash.

Кроме обычных зависимостей, NPM отдельно обрабатывает зависимости необходимые только во время разработки. К таким пакетам относятся тестовые фреймворки и тому подобные вещи. Их установка немного отличается:

npm install --save-dev jest

Флаг --save-dev приводит к тому что зависимость добавляется в секцию devDependencies файла package.json. Эти зависимости никак не используются при публикации пакета, что позволяет экономить память.
Сами зависимости не хранятся в git-репозитории и должны быть добавлены в .gitignore:
// .gitignore
node_modules

Если вы клонировали репозиторий с гитхаба, директория node_modules будет отсутствовать, как и пакеты в ней. Первое, что нужно сделать в этом случае — выполнить команду npm install. Эта команда, запущенная без аргументов, выполняет установку тех пакетов, которые указаны в файле package.json. Она запускается в разных случаях: если вы удалили папку node_modules и хотите снова ее восстановить или если вы только что клонировали репозиторий. Установка пакетов — идемпотентная операция, поэтому ее можно запускать сколько угодно раз, не боясь что-либо сломать.

Обновление зависимостей
npm update
npm update name

обновление, зависит от того, что написано в package.json
dependencies {
  'package1': "*", //можно ставить любую версию библиотеки
  'package2': "1.3.5",//Если версия библиотеки жестко зафиксирована, никакая команда не сможет обновить ее.
  'package3': "~2.3.4",//в автоматическом режиме обновляются только патчи.
  'package4': "^2.3.4",//фиксирует мажорную версию, обновляется минорная и патч.
}

в package.json указываются зависимости,  у каждой зависимости могут быть свои собственные зависимости, которые тоже обновляются — и так до бесконечности. Зависимости зависимостей называются транзитивными и с ними не все так просто. Настолько не просто, что существует понятие "dependency hell" (ад зависимостей).

lock файл автоматизированно отслеживает зависимости всех зависимостей и явно прописывает их версии в package.json. 
Первый запуск установки зависимостей формирует этот файл. Туда записываются все установленные зависимости, в том числе транзитивные, и их версии. При дальнейших запусках npm install всегда ставится то, что указано в lock файле, даже если стереть папку node_modules, а в npm-хранилище добавятся новые версии пакетов. Повторный запуск через любой промежуток времени приведет к тому же результату. Теперь всегда можно быть уверенным, что если заработало сейчас, то заработает потом и не только у нас.

Наличие lock файла никак не влияет на поведение команды update для прямых зависимостей. Если пакет, указанный в package.json, обновился и может быть обновлен до указанной версии, то загрузится новая версия, а файл lock обновится автоматически. После этого нужно не забыть залить его в git-репозиторий.

На самом деле, lock-файл ведет себя сложнее, но для понимания схемы его работы достаточно описанного выше. Если хотите разобраться в теме от и до — изучите официальную документацию.

Как и любой автоматически генерируемый файл, lock-файл не может правиться вручную, потому что ваши изменения сразу будут сброшены при следующей генерации.

Не все устанавливаемые зависимости, используются внутри кода как библиотеки. Некоторые нужны для различных утилитарных задач. К подобным пакетам относится eslint.
Глобальная установка позволяет установить eslint один раз и затем использовать его во всех необходимых пакетах, которые мы разрабатываем
Если я глобально установлю себе еслинт и размещу свою библиотеку на гитхабе, а кто то ее склонирует и попробует установить все зависимости через npm install, то у него еслинт не поставится т.к. глобальные зависимости не ставятся при первоначальной настройке пакета. То есть если мы выполним команду npm install в свежесклонированном репозитории, eslint не поставится, а значит придется устанавливать его отдельно. И это придется делать не только нам, но и всем кто участвует в разработке данного пакета. К тому же возможны проблемы с версиями. Если у кого-то стоит eslint старой версии, это может помешать нормальной проверке, и в такой ситуации не будет никакой возможности обновить версию пакета автоматически, это произойдет только если разработчик сам вспомнит о том, что пакет стоит обновить.

Поэтому наш выбор - локальная установка. Подобные пакеты всегда используются только при разработке, поэтому не забываем указывать флаг --save-dev во время локальной установки.

# В корне проекта
$ npm install --save-dev eslint

Если попробовать его запустить как обычно, то bash скажет что команда не найдена.

# В корне проекта
$ eslint .
bash: eslint: command not found
