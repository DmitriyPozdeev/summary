Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.
Таково стандартное определение, которое есть в Wikipedia и большинстве серьёзных источников по программированию. То есть, замыкание – это функция + внешние переменные.
Тем не менее, в JavaScript есть небольшая терминологическая особенность.
Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные.
Иногда говорят «переменная берётся из замыкания». Это означает – из внешнего объекта переменных.
«Понимать замыкания» в JavaScript означает понимать следующие вещи:
> Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.
> При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.
> При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».


function makeCounter() {//ОБЪЯВЛЯЮ новую функцию
  // LexicalEnvironment = { currentCount: undefined }

  var currentCount = 1;

  // LexicalEnvironment = { currentCount: 1 }

  return function() { // [[Scope]] -> LexicalEnvironment (**)
    return currentCount++;
  };
}

var counter = makeCounter(); // (*) ПРИСВАЮВАЮ РЕЗУЛЬТАТ работы функции makeCounter() переменной 
Итоговым значением, записанным в переменную counter, является функция:

function() { // [[Scope]] -> {currentCount: 1}
  return currentCount++; //Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения.
};
Когда вы объявляете новую функцию и присваиваете её переменной, то в этой переменной вы храните не только определение функции, но и её замыкание. Замыкание содержит все переменные, которые находятся в области видимости во время создания функции.
Т.е вот так:
var counter = function() { // [[Scope]] -> {currentCount: 1}
  return currentCount++;
};
console.log(counter()); //Возвращает старое значение значение, но увеличивает currentCount