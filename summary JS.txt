Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.
Таково стандартное определение, которое есть в Wikipedia и большинстве серьёзных источников по программированию. То есть, замыкание – это функция + внешние переменные.
Тем не менее, в JavaScript есть небольшая терминологическая особенность.
Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные.
Иногда говорят «переменная берётся из замыкания». Это означает – из внешнего объекта переменных.

«Понимать замыкания» в JavaScript означает понимать следующие вещи:
> Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.

> При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.

> При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».

Создание функции 
=> Получение свойства [[Scope]] c ссылкой на LE в котором ф-ция была создана 
=> Запуск функции 
=> Создание LE{} и получение ссылки на внешнее LE из [[Scope]]
=> Заполнение LE{variables: values} => Выполнение функции 
=> При доступе к переменной происходит поиск в текущем LE, если не находит то ищет во внешнем LE

При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.


function makeCounter() {//ОБЪЯВЛЯЮ новую функцию
  // LexicalEnvironment = { currentCount: undefined }

  var currentCount = 1;

  // LexicalEnvironment = { currentCount: 1 }

  return function() { // [[Scope]] -> LexicalEnvironment (**)
    return currentCount++;
  };
}

var counter = makeCounter(); // (*) ПРИСВАЮВАЮ РЕЗУЛЬТАТ работы функции makeCounter() переменной counter
Итоговым значением, записанным в переменную counter, является функция:

function() { // [[Scope]] -> {currentCount: 1}
  return currentCount++; //Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения.
};
Когда вы объявляете новую функцию и присваиваете её переменной, то в этой переменной вы храните не только определение функции, но и её замыкание. Замыкание содержит все переменные, которые находятся в области видимости во время создания функции.
Т.е вот так:
var counter = function() { // [[Scope]] -> {currentCount: 1}
  return currentCount++;
};
console.log(counter()); //Возвращает старое значение значение, но увеличивает currentCount//1

   Модули через замыкания
Модуль при помощи замыканий – это оборачивание пакета функционала в единую внешнюю функцию, которая тут же выполняется.

Все функции модуля будут иметь доступ к другим переменным и внутренним функциям этого же модуля через замыкание.
Но снаружи программист, использующий модуль, может обращаться напрямую только к тем переменным и функциям, которые экспортированы. Благодаря этому будут скрыты внутренние аспекты реализации, которые нужны только разработчику модуля.

Можно придумать и много других вариаций такого подхода. В конце концов, «модуль» – это всего лишь функция-обёртка для скрытия переменных.

 Управление памятью в JavaScript

Главной концепцией управления памятью в JavaScript является принцип достижимости (англ. reachability).

Определённое множество значений считается достижимым изначально, в частности:
Значения, ссылки на которые содержатся в стеке вызова, то есть – все локальные переменные и параметры функций, которые в настоящий момент выполняются или находятся в ожидании окончания вложенного вызова.

Все глобальные переменные.

Эти значения гарантированно хранятся в памяти. Мы будем называть их корнями.