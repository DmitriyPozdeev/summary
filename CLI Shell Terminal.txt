



Потоки
 В каждом языке есть собственный способ напечатать результат на экран. С точки зрения операционной системы, которая запускает программу, все они работают абсолютно идентично.
При старте любой программы операционная система связывает с ней три так называемых потока: STDIN (Standar*d* Input), STDOUT (Standar*d* Output) и STDERR. Для языка программирования, они выглядят как файлы и взаимодействие с ними происходит как с файлами. STDOUT как раз отвечает за вывод на экран. Каждый раз, когда в программе (на любом языке) происходит печать на экран, функция печати, на самом деле, записывает с помощью функции write данные в STDOUT, а вот уже операционная система решает куда вывести результат. По умолчанию вывод происходит на экран терминала.
ЯП write STDOUT

Ответственность за взаимодействие с железом целиком и полностью лежит на плечах операционной системы, а программы могут только лишь попросить операционную систему выполнить ту или иную задачу.
 
ОС позволяет подменять эти потоки при старте системы, что открывает интересные возможности. Например, вывод любой команды, запущенной в баше, можно записать в файл вместо вывода на экран.
$ ls -la > output
Запустив эту команду, вы увидите, что на экране ничего не отобразилось, но в текущей директории появился файл output.
Это называется перенаправление потоков. Символ > означает, что нужно взять вывод из команды, указанной слева, и отправить его в файл, указанный справа. > всегда перезаписывает файл. Такое перенаправление работает с абсолютно любой командой, которая выводит результаты своей работы на экран.
Если нужно не перезаписывать, а добавлять, то используйте >>.

STDERR по умолчанию идёт на экран. Он позволяет отделить нормальный вывод программы от возникающих ошибок. Такой подход удобен при ведении логов, для реагирования и отладки. Будьте осторожны, перенаправление вывода в файл перенаправляет только STDOUT. Убедиться в этом очень просто. Если попробовать перейти в несуществующую директорию, то команда cd выдаст ошибку:

$ cd lala
-bash: cd: lala: No such file or directory
Теперь попробуем перенаправить вывод в файл output

$ cd lala > output
-bash: cd: lala: No such file or directory

Перенаправление есть, но сообщение вывелось на экран. Это произошло именно по той причине, что STDERR остался привязан к экрану, а внутри файла output — пустота. Решить эту задачу можно двумя способами. Перенаправив STDERR в STDOUT, либо отправив их оба в файл.

Перенаправление STDERR в STDOUT


$ cd lala > output 2>&1
$ cat output
-bash: cd: lala: No such file or directory
2 - в данном случае обозначает номер потока. В POSIX, за каждым потоком закреплен определенный номер, который является файловым дескриптором если быть точным: STDIN — 0, STDOUT — 1, STDERR — 2. Конструкцию 2>&1 нужно просто запомнить, она говорит о том, что поток с номером 2 отправляем в поток с номером 1

Перенаправление STDERR бывает полезно само по себе, без вывода в файл.


$ cd lala 2>&1
-bash: cd: lala: No such file or directory

Перенаправление обоих потоков в файл


$ cd lala &> output
$ cat output
-bash: cd: lala: No such file or directory

Пайплайн(Конвейер) Pipeline

Благодаря пайплайну можно соединять программы и протаскивать данные сквозь них, как сквозь цепочку функций, каждая из которых выступает в роли преобразователя или фильтра.

Часто возникает задача грепать по нескольким словам. Не важно, как они расположены внутри строки, главное, что они встречаются там вместе. 
$ grep alias .bashrc | grep color

| — этот символ называется пайп, он указывает шелу взять STDOUT одного процесса и соединяет его с STDIN другого процесса. Поскольку grep принимает на вход текст (как я говорил в прошлом уроке, все утилиты, которые читают файлы, могут принимать данные через STDIN) и возвращает текст, то его можно комбинировать бесконечно.

cat source | grep Dog | uniq | sort

1.Читается файл source
2.Входные данные грепаются по подстроке "Dog"
3.Убираются дубли (в исходном файле две одинаковых строки "Dog")
4.Входные данные сортируются и выводятся на экран

Пайплайн стал основой Unix философии, которая звучит так:

    Пишите программы, которые делают что-то одно и делают это хорошо.
    Пишите программы, которые бы работали вместе.
    Пишите программы, которые бы поддерживали текстовые потоки, поскольку это универсальный интерфейс.

Именно поэтому большинство утилит работают с сырым текстом — принимают его на вход и возвращают в STDOUT. Такой подход позволяет получать сложное поведение из крайне простых составных блоков. Такая концепция называется стандартные интерфейсы и хорошо отражена в конструкторах Lego.

Манипулирование файловой структурой
mkdir - создание директории -p, который создаёт директории рекурсивно.
touch - создание файла
rm - удаление файла -r режим рекурсивного (r - recursion) удаления содержимого директорий 
mv - В nix системах не существует понятия "переименовать файл". Переименование всегда равносильно перемещению
cp - копирование файлов и директорий Для копирования директории нужно добавить флаг -r (recursive).

Переменные окружения
Они существуют в рамках запущенной сессии командного интерпретатора, подгружаются туда во время его инициализации (но это не единственный путь их появления). Посмотреть установленные переменные можно командой env (environment). 
Основное предназначение переменных окружения — конфигурация системы и программ. Их удобство заключается в универсальности и отвязке от способа появления этих значений в системе. 
Существует некоторый базовый набор переменных, которые всегда устанавливаются башем при старте. Они используются большим количеством утилит и нужны для нормального функционирования системы, одну из таких переменных мы уже знаем — это HOME.

По умолчанию, любой запущенный процесс получает все переменные родительского процесса (процесс-создатель). Именно поэтому команда cd может прочитать переменную HOME. Переменные можно создавать и изменять в любой момент времени, например:

# Для вывода переменной используется echo, а перед самой переменной ставится знак $.
$ echo $HOME
/home/kirill.m
# Для установки знак $ не нужен.
# Очень важно чтобы не было пробелов вокруг знака равно
$ HOME=/tmp


# Достаточно выполнить присваивание слева от запускаемой команды
$ HOME=/tmp cd
/tmp$ pwd
/tmp

$ cd
~$ pwd
/home/kirill.m
~$ echo $HOME
/home/kirill.m

В этот раз произошел переход в настоящую домашнюю директорию. Получается, что вызов выше изменил переменную только для того конкретного запуска. И действительно, существует два способа задавать значение переменной окружения: локальный и глобальный. 
Когда мы указали HOME=/tmp прямо перед командой cd, то переменная не была изменена для текущей сессии — она была изменена для запущенной команды, в данном случае cd. Такой трюк можно проделывать с любой командой. Другой способ установки изменяет значение глобально, для всей сессии и выполняется так:

~$ export HOME=/tmp
/home/kirill.m$ cd
~$ pwd
/tmp
~$ echo $HOME
/tmp

Обратите внимание на то, что изменение происходит в рамках текущей сессии, другими словами, если у вас открыто две вкладки терминала, и в каждой загружен баш, то изменение произойдет только в той вкладке, в которой будет выполнена команда.

Особую роль среди переменных окружения играет переменная PATH. Она настолько важна для разработчиков и так часто возникают связанные с ней сложности, что этой переменной посвящён практически целый урок впереди.




