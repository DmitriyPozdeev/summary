



Потоки
 В каждом языке есть собственный способ напечатать результат на экран. С точки зрения операционной системы, которая запускает программу, все они работают абсолютно идентично.
При старте любой программы операционная система связывает с ней три так называемых потока: STDIN (Standar*d* Input), STDOUT (Standar*d* Output) и STDERR. Для языка программирования, они выглядят как файлы и взаимодействие с ними происходит как с файлами. STDOUT как раз отвечает за вывод на экран. Каждый раз, когда в программе (на любом языке) происходит печать на экран, функция печати, на самом деле, записывает с помощью функции write данные в STDOUT, а вот уже операционная система решает куда вывести результат. По умолчанию вывод происходит на экран терминала.
ЯП write STDOUT

Ответственность за взаимодействие с железом целиком и полностью лежит на плечах операционной системы, а программы могут только лишь попросить операционную систему выполнить ту или иную задачу.
 
ОС позволяет подменять эти потоки при старте системы, что открывает интересные возможности. Например, вывод любой команды, запущенной в баше, можно записать в файл вместо вывода на экран.
$ ls -la > output
Запустив эту команду, вы увидите, что на экране ничего не отобразилось, но в текущей директории появился файл output.
Это называется перенаправление потоков. Символ > означает, что нужно взять вывод из команды, указанной слева, и отправить его в файл, указанный справа. > всегда перезаписывает файл. Такое перенаправление работает с абсолютно любой командой, которая выводит результаты своей работы на экран.
Если нужно не перезаписывать, а добавлять, то используйте >>.

STDERR по умолчанию идёт на экран. Он позволяет отделить нормальный вывод программы от возникающих ошибок. Такой подход удобен при ведении логов, для реагирования и отладки. Будьте осторожны, перенаправление вывода в файл перенаправляет только STDOUT. Убедиться в этом очень просто. Если попробовать перейти в несуществующую директорию, то команда cd выдаст ошибку:

$ cd lala
-bash: cd: lala: No such file or directory
Теперь попробуем перенаправить вывод в файл output

$ cd lala > output
-bash: cd: lala: No such file or directory

Перенаправление есть, но сообщение вывелось на экран. Это произошло именно по той причине, что STDERR остался привязан к экрану, а внутри файла output — пустота. Решить эту задачу можно двумя способами. Перенаправив STDERR в STDOUT, либо отправив их оба в файл.

Перенаправление STDERR в STDOUT


$ cd lala > output 2>&1
$ cat output
-bash: cd: lala: No such file or directory
2 - в данном случае обозначает номер потока. В POSIX, за каждым потоком закреплен определенный номер, который является файловым дескриптором если быть точным: STDIN — 0, STDOUT — 1, STDERR — 2. Конструкцию 2>&1 нужно просто запомнить, она говорит о том, что поток с номером 2 отправляем в поток с номером 1

Перенаправление STDERR бывает полезно само по себе, без вывода в файл.


$ cd lala 2>&1
-bash: cd: lala: No such file or directory

Перенаправление обоих потоков в файл


$ cd lala &> output
$ cat output
-bash: cd: lala: No such file or directory

Пайплайн(Конвейер) Pipeline

Благодаря пайплайну можно соединять программы и протаскивать данные сквозь них, как сквозь цепочку функций, каждая из которых выступает в роли преобразователя или фильтра.

Часто возникает задача грепать по нескольким словам. Не важно, как они расположены внутри строки, главное, что они встречаются там вместе. 
$ grep alias .bashrc | grep color

| — этот символ называется пайп, он указывает шелу взять STDOUT одного процесса и соединяет его с STDIN другого процесса. Поскольку grep принимает на вход текст (как я говорил в прошлом уроке, все утилиты, которые читают файлы, могут принимать данные через STDIN) и возвращает текст, то его можно комбинировать бесконечно.

cat source | grep Dog | uniq | sort

1.Читается файл source
2.Входные данные грепаются по подстроке "Dog"
3.Убираются дубли (в исходном файле две одинаковых строки "Dog")
4.Входные данные сортируются и выводятся на экран

Пайплайн стал основой Unix философии, которая звучит так:

    Пишите программы, которые делают что-то одно и делают это хорошо.
    Пишите программы, которые бы работали вместе.
    Пишите программы, которые бы поддерживали текстовые потоки, поскольку это универсальный интерфейс.

Именно поэтому большинство утилит работают с сырым текстом — принимают его на вход и возвращают в STDOUT. Такой подход позволяет получать сложное поведение из крайне простых составных блоков. Такая концепция называется стандартные интерфейсы и хорошо отражена в конструкторах Lego.

Манипулирование файловой структурой
mkdir - создание директории -p, который создаёт директории рекурсивно.
touch - создание файла
rm - удаление файла -r режим рекурсивного (r - recursion) удаления содержимого директорий 
mv - В nix системах не существует понятия "переименовать файл". Переименование всегда равносильно перемещению
cp - копирование файлов и директорий Для копирования директории нужно добавить флаг -r (recursive).

Переменные окружения
Они существуют в рамках запущенной сессии командного интерпретатора, подгружаются туда во время его инициализации (но это не единственный путь их появления). Посмотреть установленные переменные можно командой env (environment). 
Основное предназначение переменных окружения — конфигурация системы и программ. Их удобство заключается в универсальности и отвязке от способа появления этих значений в системе. 
Существует некоторый базовый набор переменных, которые всегда устанавливаются башем при старте. Они используются большим количеством утилит и нужны для нормального функционирования системы, одну из таких переменных мы уже знаем — это HOME.

По умолчанию, любой запущенный процесс получает все переменные родительского процесса (процесс-создатель). Именно поэтому команда cd может прочитать переменную HOME. Переменные можно создавать и изменять в любой момент времени, например:

# Для вывода переменной используется echo, а перед самой переменной ставится знак $.
$ echo $HOME
/home/kirill.m
# Для установки знак $ не нужен.
# Очень важно чтобы не было пробелов вокруг знака равно
$ HOME=/tmp


# Достаточно выполнить присваивание слева от запускаемой команды
$ HOME=/tmp cd
/tmp$ pwd
/tmp

$ cd
~$ pwd
/home/kirill.m
~$ echo $HOME
/home/kirill.m

В этот раз произошел переход в настоящую домашнюю директорию. Получается, что вызов выше изменил переменную только для того конкретного запуска. И действительно, существует два способа задавать значение переменной окружения: локальный и глобальный. 
Когда мы указали HOME=/tmp прямо перед командой cd, то переменная не была изменена для текущей сессии — она была изменена для запущенной команды, в данном случае cd. Такой трюк можно проделывать с любой командой. Другой способ установки изменяет значение глобально, для всей сессии и выполняется так:

~$ export HOME=/tmp
/home/kirill.m$ cd
~$ pwd
/tmp
~$ echo $HOME
/tmp

Обратите внимание на то, что изменение происходит в рамках текущей сессии, другими словами, если у вас открыто две вкладки терминала, и в каждой загружен баш, то изменение произойдет только в той вкладке, в которой будет выполнена команда.

Особую роль среди переменных окружения играет переменная PATH. Она настолько важна для разработчиков и так часто возникают связанные с ней сложности, что этой переменной посвящён практически целый урок впереди.

Пользователи и Группы

Оболочка предоставляет утилиты, позволяющие анализировать права доступа к системе и изменять их.
Взаимодействие с ОС всегда ведётся от какого-то конкретного пользователя, созданного в системе. 
Любой процесс, запускаемый в ОС, стартует от имени некоторого пользователя.  Возможности влияния на файловую систему ограничены правами пользователя, от имени которого запущен процесс. Не "пользователь запустил процесс", а "процесс запускается от имени пользователя". Работая в командной строке мы стартуем всё сами, но когда система загружается, то она стартует множество различных процессов и для многих из них создаются собственные пользователи с ограниченным набором прав. Команда ps (process status) выводит отчёт о работающих процессах. Информацию о том, какой процесс и под каким пользователем запущен, можно получить из вывода ps aux:
$ ps aux
# Левый столбец имя пользователя
root      7717  0.0  0.0   4244  1504 ?        S    10:52   0:00 mpstat 1 3
kirill.m  7718  0.0  0.1  36084  3236 pts/0    R+   10:52   0:00 ps aux
alexand+ 10542  0.0  0.1  21500  2892 pts/1    Ss+  10:10   0:00 -bash
root     11113  0.0  0.1  92796  2596 ?        Ss   08:50   0:00 sshd: kirill.m [priv]

Взаимодействие с файловой системой происходит через запуск тех или иных утилит, модифицирующих, создающих или анализирующих файловую структуру. Это значит, что запуская, например, touch, мы стартуем процесс от своего имени, внутри которого запускается программа touch. Она, в свою очередь, создаёт файл (если его не было) и делает вас владельцем нового файла. Кстати, модификация существующих файлов не влияет на владельца — для его смены нужно воспользоваться специальной утилитой. В домашней директории пользователя всё принадлежит пользователю (хотя, если постараться, то можно навертеть как угодно):

$ ls -la
total 44
drwxr-xr-x 5 kirill.m kirill.m 4096 Aug 29 11:34 .
drwxr-xr-x 8 root     root     4096 Apr 26 10:38 ..
-rw------- 1 kirill.m kirill.m 2540 Aug 30 07:26 .bash_history
-rw-r--r-- 1 kirill.m kirill.m  220 Aug 31  2015 .bash_logout
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc

Третий столбец в этом выводе — как раз владелец. Единственная запись, которая выбивается из всего списка это .., то есть родительская директория. Её владельцем является root, о котором мы позже поговорим. Если хорошо подумать, то это логично — ведь директория /home не является собственностью пользователей системы:

$ ls -la /home/
total 32
drwxr-xr-x  8 root              root              4096 Apr 26 10:38 .
drwxr-xr-x 23 root              root              4096 Aug 27 06:53 ..
drwxr-xr-x  5 alexander.v       alexander.v       4096 Jan 22  2018 alexander.v

Каждый каталог в директории /home является домашним каталогом конкретного пользователя. Поэтому они все имеют разных владельцев, как правило, совпадающих с именем директории.

Имя пользователя в системе должно быть уникальным, но его можно менять. Если посмотреть под капот работы этой системы, то мы увидим, что имя пользователя связано с идентификатором, называемым UID. Это число, которое и определяет пользователя. Если поменяется имя пользователя, но идентификатор останется прежним, то все доступы останутся. Если же сменится идентификатор, то фактически сменится и пользователь. Соответственно, новый пользователь потеряет доступы ко всему старому. Посмотреть свой идентификатор можно разными способами. Первый способ — с помощью команды id:

$ id
uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)

Второй способ связан с просмотром одного важного файла, который является основным хранилищем пользователей в *nix системах. Да, это обычный текстовый файл, как и всё остальное.

$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync

Кроме имени и идентификатора, здесь также указана домашняя директория пользователя (и её можно поменять), а так же шелл по умолчанию. Запись /usr/sbin/nologin говорит о том, что данный пользователь не может входить в систему. Такие пользователи нужны для запуска программ, имеющих ограниченные права, и им, естественно, не нужно входить в систему.
Кроме имени и идентификатора, здесь также указана домашняя директория пользователя (и её можно поменять), а так же шелл по умолчанию. Запись /usr/sbin/nologin говорит о том, что данный пользователь не может входить в систему. Такие пользователи нужны для запуска программ, имеющих ограниченные права, и им, естественно, не нужно входить в систему.

Кроме имени, у пользователей *nix систем есть связанное с ним понятие группа. Группа, как можно догадаться из названия, создана для группового доступа к разделяемому (общему) ресурсу (например, файлу). Например, у нас есть группа разработчиков, которые регулярно ходят на сервер, и им нужно дать одинаковые возможности по управлению определёнными файлами. Так как владелец у файла ровно один, то мы не можем решить этот вопрос через смену владельца, но можем через создание группы. Достаточно её создать и привязать к самому пользователю. Группы, ассоциированные с текущим пользователем, показываются в выводе команды id:

$ id
uid=1002(kirill.m) gid=1002(kirill.m) groups=1002(kirill.m),999(docker)

Здесь группа kirill.m является основной, такая группа может быть только одна, и именно в эту группу входят любые создаваемые файлы от имени текущего пользователя. Кроме основной, пользователь может входить в произвольное число дополнительных групп.

В любой *nix системе присутствует специальный пользователь root, или, как говорят, суперпользователь. Главная его особенность — это идентификатор со значением 0 (а имя в теории можно поменять). Этот пользователь имеет особое значение для системы и может выполнять абсолютно любые действия в системе.

Крайне не рекомендуется использовать этого пользователя на регулярной основе. И ни в коем случае нельзя входить под ним в систему. root — это прямой доступ ко всему и большая дыра в безопасности системы. Кроме того, систему очень легко убить, например, удалив случайно не тот файл или испортив важную конфигурацию, после чего вход в систему станет невозможным.

Несмотря на это, root нужен для выполнения некоторых привилегированных действий, которые недоступны обычным пользователям. 

root sudo

Ситуаций, в которых необходимо повышать привилегии и выполнять команды от рута (пользователя root), довольно много. С некоторыми мы уже столкнулись, с другими познакомимся в следующих уроках:

    Установка новых программ
    Навигация по чужим директориям
    Изменение прав доступа и владельцев файлов, не принадлежащих текущему пользователю
    Создание, редактирование и удаление файлов в местах, где не хватает прав текущего пользователя
    Запуск программ, требующих повышенные привилегии

Стать другим пользователем, находясь прямо в системе, можно с помощью утилиты su (substitute user, switch user). Когда-то такой способ был основным, но сейчас он устарел и крайне не рекомендуется к использованию. Подробнее об этом можно прочитать в статье из дополнительных материалов. Основной способ повышать привилегии в современных системах — утилита sudo (substitute user and do — дословно "подменить пользователя и выполнить").

$ sudo -u nobody mkdir /tmp/test
# Файл создан от nobody

Если стоит задача произвести сразу пачку действий от имени другого пользователя, то для этого можно запустить новую сессию поверх текущей:

$ sudo -i
$ id
uid=0(root) gid=0(root) groups=0(root)

Главное — не забыть переключиться обратно после завершения необходимых манипуляций. Для этого наберите exit.

Права доступа
Частая ошибка, с которой встречаются разработчики — ошибка доступа:

$ touch /etc/myfile
touch: cannot touch '/etc/myfile': Permission denied

Она говорит о том, что текущий пользователь не имеет прав на создание файлов в каталоге /etc.
Кроме имени пользователя и группы, с каждым файлом ассоциированы права доступа: r — чтение, w — запись и x — исполнение. Причём, эти права задаются для трёх типов пользователей: владельца (Owner), пользователей, входящих в ту же группу (Group) и остальных (Other) — тех, кто не попал в предыдущие две. Разберём на примере:

# Пример строчки из вывода команды ls -la
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc

Запись слева представляет из себя один из вариантов описания прав доступа (permissions). Для удобства чтения разделим эту запись на группы символов - rw- r-- r--. Символ - в этой записи говорит о том, что перед нами обычный файл. За ним следует три группы, в каждой из которых по три символа. Каждая группа описывает доступы для разных типов пользователей. 

Удалить файл можно только, если у вас есть возможность писать в эту директорию (в соответствии с тем, к какому типу пользователей вы относитесь).
$ ls -la /home/ | grep kirill

drwxr-xr-x  5 kirill.m          kirill.m          4096 Aug 29 11:34 kirill.m

Домашняя директория имеет другие права. Первое отличие — это d вместо - в самом начале. d говорит о том, что перед нами директория. Права для владельца rwx, а для всех остальных r-x. Из этого описания видно, что кроме пользователя никто не может писать внутрь домашней директории этого пользователя.

Что такое x в отношении директорий? Это право позволяет перемещаться в директорию и обращаться ко всем расположенным в ней файлам и каталогам. Обращаться можно при условии, что эти файлы доступны на чтение или запись или выполнение: например, если положить доступный на чтение файл в директорию с правом x, то вы сможете прочитать этот файл. Если же убрать с директории право x, то вы вовсе лишитесь доступа к файлу.

Но что тогда такое чтение? Здесь всё более интуитивно понятно: директория, по сути, является списком файлов, поэтому право на чтение позволяет прочитать этот список файлов, а именно вывести список имён файлов, содержащихся в директории. Однако, если хотите посмотреть не простой список имён файлов, а список с дополнительной информацией (как при выводе ls -l), то требуется ещё и право x, потому что в этом случае надо обращаться к файлам за их метаданными (владелец, группа, дата изменения, права и др.). В любом случае, без права r на каталог вы не сможете посмотреть его содержимое.

В литературе (статьях, книгах, мануалах) иногда используется другой способ описания прав доступа: 775. Это не одно число, а три числа, каждое из которых представляет собой группу rwx для наших типов пользователя в том же порядке: для владельца, входящих в группу и всех остальных. 0 — означает, что нет никаких прав для данного типа пользователей.

 	A 	B 	C 	D
1 	# 	Permission 	rwx 	Binary
2 	7 	read, write and execute 	rwx 	111
3 	6 	read and write 	rw- 	110
4 	5 	read and execute 	r-x 	101
5 	4 	read only 	r-- 	100
6 	3 	write and execute 	-wx 	011
7 	2 	write only 	-w- 	010
8 	1 	execute only 	--x 	001

drwxr-xr-x в числовой форме соответствует 755, а -rw-r--r-- — 644.

Однако пользователь root находится вне этой системы. Для него не имеет никакого значения наличие любых прав — рут может всё.

 Пакетный менеджер
Для установки программ, особенно связанных с разработкой, придумали пакетные менеджеры. Далее, для всех примеров я буду использовать пакетный менеджер apt, который поставляется с Ubuntu.

Например, установка php в Ubuntu выглядит так:

$ sudo apt install php
# Здесь будет много текста и вопрос, устанавливать ли? Если да, то установится php
$ php -v
PHP 7.2.7 (cli) (built: Jun 22 2018 06:27:50) ( NTS )

Пакетный менеджер состоит из нескольких частей. Одна из них взаимодействует с пользователем напрямую — это консольная утилита apt. Для установки необходимой программы нужно набрать apt install и далее указать её имя. Почти всегда пакетные менеджеры требуют запуска от рута (root), так как установка программ происходит в системные директории, недоступные для записи обычному пользователю (но это не всегда так, в MacOS не нужно использовать sudo).

Установленные пакеты можно удалять. Для этого используется команда apt remove:

$ apt remove php
# Тут тоже много вывода и вопрос, удалять ли?

На другом конце провода находится каталог так называемых пакетов. Во время попытки установить программу утилита apt выполняет запрос в каталог и пытается понять, есть ли там пакет с таким именем. Если его нет, то вы об этом узнаете:

# Пакета wrongname не существует
$ sudo apt install wrongname
Reading package lists... Done
Building dependency tree
Reading state information... Done
E: Unable to locate package wrongname

Для экономии ресурсов (сети) и ускорения работы apt сохраняет индекс (список пакетов в каталоге) на локальный диск и использует его для своей работы. Иногда это может приводить к ситуациям, что пакет в реальности существует, но apt утверждает обратное. Если вы чувствуете подвох, то запустите ручное обновление локального индекса:

$ sudo apt update
# Теперь можно устанавливать
$ sudo apt install php



    Как узнать какой пакет ставить?

    Когда появляется необходимость установить определённую программу, то самый очевидный способ сделать это, найти сайт программы и выполнить действия, указанные на странице "Скачать" (обычно Download). Как правило, на этой странице есть указание о том, как можно использовать пакетный менеджер, с примерами команд, включающих в себя названия пакета. Пример: nodejs.

    Другой способ: загуглить статьи в стиле php install ubuntu. В таких статьях установка всегда идёт через пакетный менеджер. Со временем вы запомните имена многих пакетов и сможете ставить их "на автомате".

    Чем пакет отличается от программы?

    Сама программа ничего не знает про существование пакетного менеджера. Но чтобы её можно было ставить через менеджер пакетов, она должна быть специальным образом "упакована". Это может сделать как автор программы, так и энтузиасты. В Ubuntu используется специальный формат пакетов, называемый deb. У этого формата есть подробная документация о том, как производить упаковку.

    Как программы попадают в каталог?

    А вот здесь всё сильно зависит от политики тех, кто его поддерживает. В некоторые каталоги попасть очень тяжело и программы в них обновляют медленно. Связано это с тем, что разработчики стараются добавлять туда только проверенный софт. В других всё происходит просто и быстро. В любом случае необходимо пройти некоторую процедуру, после которой программа будет добавлена. Это один из ключевых аспектов, по которому дистрибутивы линукса отличаются друг от друга. В любом случае эти каталоги огромны, в них входят десятки и сотни тысяч программ и библиотек.

Пакетные менеджеры не являются прерогативой операционных систем: любая экосистема, внутри которой возможно распространение библиотек или программ, имеет свой пакетный менеджер. Пакетные менеджеры есть у всех языков программирования, иногда несколько, большинство из них включены в языки по умолчанию. В nodejs (серверный javascript) пакетный менеджер npm, в php — composer, в ruby — gem, в python — pip.

 Выполнение программ

Очень важно понимать, как работает механизм по поиску и выполнению программы, так как проблемы с запуском вновь установленных программ возникают регулярно у всех разработчиков.
Программа всего лишь файл или набор файлов на диске. Один из этих файлов обязательно должен быть исполняемым. 
выполнить программу можно только если она исполняемая, иначе попытка запустить её приведёт к ошибке.

Весь механизм по запуску программ в *Nix системах основан на соглашениях. Когда в командной строке вводится некоторая команда, например, ls, то шел начинает поиск исполняемого файла с именем ls в списке директорий, указанном в переменной окружения PATH.

~$ echo $PATH
/home/hex/.local/bin:/home/hex/bin/:/home/hex/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:

Директории друг от друга отделяются двоеточием. В этом списке присутствуют как общесистемные пути, так и пути, специфичные для конкретного пользователя. Процесс поиска программы выглядит следующим образом. Шел перебирает директории слева направо и ищет ту, в которой есть файл ls, доступный для исполнения. Если такого файла не оказалось, то выводится ошибка:

~$ wrongname
bash: wrongname: command not found

важен порядок. Если файл с одним и тем же именем находится одновременно в нескольких директориях, то будет найден тот, который находится в директории, расположенной левее.

Если вам интересно узнать, а где лежит исполняемый файл конкретной программы, то можно воспользоваться командой type (а еще which и whereis):

~$ type cp
cp is /bin/cp
~$
~$ whereis cp
cp: /bin/cp
~$
~$ which cp
/bin/cp
~$
~$ ls -al /bin | grep cp
-rwxr-xr-x 1 root root  141528 Jan 18  2018 cp







